<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The small3d library: vkzos.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_s.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The small3d library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c4e392f45bbb0200e63f7c43bd1c92dc.html">small3d</a></li><li class="navelem"><a class="el" href="dir_f8b74d05d79b1108f15ac4f7f6bb3175.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vkzos.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Vulkan helper functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;vulkan/vulkan.h&gt;</code><br />
</div>
<p><a href="vkzos_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af6e9b9e46e4bddcd0b7076bfbbfbb815"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#af6e9b9e46e4bddcd0b7076bfbbfbb815">vkz_create_instance</a> (const char *application_name, const char **enabled_extension_names, size_t enabled_extension_count)</td></tr>
<tr class="memdesc:af6e9b9e46e4bddcd0b7076bfbbfbb815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vulkan instance.  <a href="vkzos_8h.html#af6e9b9e46e4bddcd0b7076bfbbfbb815">More...</a><br /></td></tr>
<tr class="separator:af6e9b9e46e4bddcd0b7076bfbbfbb815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d928e1d6442c9aec817f5562a86c905"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a3d928e1d6442c9aec817f5562a86c905">vkz_init</a> (void)</td></tr>
<tr class="memdesc:a3d928e1d6442c9aec817f5562a86c905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise. Internally this means create physical device, select queue families and create logical device.  <a href="vkzos_8h.html#a3d928e1d6442c9aec817f5562a86c905">More...</a><br /></td></tr>
<tr class="separator:a3d928e1d6442c9aec817f5562a86c905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0195411e2f1dc0e86ea9e288cece7dbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a0195411e2f1dc0e86ea9e288cece7dbb">vkz_set_width_height</a> (const uint32_t width, const uint32_t height)</td></tr>
<tr class="memdesc:a0195411e2f1dc0e86ea9e288cece7dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set width and height for all rendering calculations.  <a href="vkzos_8h.html#a0195411e2f1dc0e86ea9e288cece7dbb">More...</a><br /></td></tr>
<tr class="separator:a0195411e2f1dc0e86ea9e288cece7dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b5b1afb79d82d63aad27004a1ec042"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#ae6b5b1afb79d82d63aad27004a1ec042">vkz_create_swapchain</a> (int with_image_sampler)</td></tr>
<tr class="memdesc:ae6b5b1afb79d82d63aad27004a1ec042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the swapchain that will be used. This will also create the associated image views.  <a href="vkzos_8h.html#ae6b5b1afb79d82d63aad27004a1ec042">More...</a><br /></td></tr>
<tr class="separator:ae6b5b1afb79d82d63aad27004a1ec042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fdc47fa92ad88c0d7ba8f37dc6da31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#ad7fdc47fa92ad88c0d7ba8f37dc6da31">vkz_destroy_swapchain</a> (void)</td></tr>
<tr class="memdesc:ad7fdc47fa92ad88c0d7ba8f37dc6da31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the swapchain.  <a href="vkzos_8h.html#ad7fdc47fa92ad88c0d7ba8f37dc6da31">More...</a><br /></td></tr>
<tr class="separator:ad7fdc47fa92ad88c0d7ba8f37dc6da31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc83914d1f7c03521b12629f0a99863"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a8bc83914d1f7c03521b12629f0a99863">vkz_create_depth_image</a> (void)</td></tr>
<tr class="memdesc:a8bc83914d1f7c03521b12629f0a99863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the image used for depth testing. This function must be called right after <a class="el" href="vkzos_8h.html#ae6b5b1afb79d82d63aad27004a1ec042" title="Create the swapchain that will be used. This will also create the associated image views.">vkz_create_swapchain()</a>.  <a href="vkzos_8h.html#a8bc83914d1f7c03521b12629f0a99863">More...</a><br /></td></tr>
<tr class="separator:a8bc83914d1f7c03521b12629f0a99863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c84cdbe4649348893435572096578c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a47c84cdbe4649348893435572096578c">vkz_destroy_depth_image</a> (void)</td></tr>
<tr class="memdesc:a47c84cdbe4649348893435572096578c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the image used for depth testing.  <a href="vkzos_8h.html#a47c84cdbe4649348893435572096578c">More...</a><br /></td></tr>
<tr class="separator:a47c84cdbe4649348893435572096578c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784cb3ffcb643a79ad4f88ffc9a8a831"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a784cb3ffcb643a79ad4f88ffc9a8a831">vkz_create_pipeline</a> (const char *vertex_shader_path, const char *fragment_shader_path, int(*set_input_state)(VkPipelineVertexInputStateCreateInfo *), int(*set_pipeline_layout)(VkPipelineLayoutCreateInfo *), uint32_t *index)</td></tr>
<tr class="memdesc:a784cb3ffcb643a79ad4f88ffc9a8a831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pipeline. This will also create associated Vulkan objects.  <a href="vkzos_8h.html#a784cb3ffcb643a79ad4f88ffc9a8a831">More...</a><br /></td></tr>
<tr class="separator:a784cb3ffcb643a79ad4f88ffc9a8a831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0e37831055659987cce0d826d24ebb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#adf0e37831055659987cce0d826d24ebb">vkz_begin_draw_command_buffer</a> (VkCommandBuffer *command_buffer)</td></tr>
<tr class="memdesc:adf0e37831055659987cce0d826d24ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin creating a drawing command buffer.  <a href="vkzos_8h.html#adf0e37831055659987cce0d826d24ebb">More...</a><br /></td></tr>
<tr class="separator:adf0e37831055659987cce0d826d24ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cc3b9c1143cf9c6b94326267593646"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a00cc3b9c1143cf9c6b94326267593646">vkz_bind_pipeline_to_command_buffer</a> (uint32_t pipeline_index, const VkCommandBuffer *command_buffer)</td></tr>
<tr class="memdesc:a00cc3b9c1143cf9c6b94326267593646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a pipeline to a command buffer.  <a href="vkzos_8h.html#a00cc3b9c1143cf9c6b94326267593646">More...</a><br /></td></tr>
<tr class="separator:a00cc3b9c1143cf9c6b94326267593646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088475389445522349c7fe98e97d4e40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a088475389445522349c7fe98e97d4e40">vkz_end_draw_command_buffer</a> (VkCommandBuffer *command_buffer)</td></tr>
<tr class="memdesc:a088475389445522349c7fe98e97d4e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish recording a command buffer.  <a href="vkzos_8h.html#a088475389445522349c7fe98e97d4e40">More...</a><br /></td></tr>
<tr class="separator:a088475389445522349c7fe98e97d4e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e75c0f91918e52ec1b69904d68f231"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a67e75c0f91918e52ec1b69904d68f231">vkz_destroy_draw_command_buffer</a> (VkCommandBuffer *command_buffer)</td></tr>
<tr class="memdesc:a67e75c0f91918e52ec1b69904d68f231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a command buffer.  <a href="vkzos_8h.html#a67e75c0f91918e52ec1b69904d68f231">More...</a><br /></td></tr>
<tr class="separator:a67e75c0f91918e52ec1b69904d68f231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2de1d94e33394ca1c2fb6e7323e778"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a5d2de1d94e33394ca1c2fb6e7323e778">vkz_create_sync_objects</a> (void)</td></tr>
<tr class="memdesc:a5d2de1d94e33394ca1c2fb6e7323e778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create sync objects.  <a href="vkzos_8h.html#a5d2de1d94e33394ca1c2fb6e7323e778">More...</a><br /></td></tr>
<tr class="separator:a5d2de1d94e33394ca1c2fb6e7323e778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca1ef6f12a537273666f109e943a778"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a1ca1ef6f12a537273666f109e943a778">vkz_destroy_sync_objects</a> (void)</td></tr>
<tr class="memdesc:a1ca1ef6f12a537273666f109e943a778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy sync objects.  <a href="vkzos_8h.html#a1ca1ef6f12a537273666f109e943a778">More...</a><br /></td></tr>
<tr class="separator:a1ca1ef6f12a537273666f109e943a778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7d08f1be55837b8d6ac2a88eda3439"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a6d7d08f1be55837b8d6ac2a88eda3439">vkz_recreate_pipelines_and_swapchain</a> (void)</td></tr>
<tr class="memdesc:a6d7d08f1be55837b8d6ac2a88eda3439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recreate the swapchain and the pipelines.  <a href="vkzos_8h.html#a6d7d08f1be55837b8d6ac2a88eda3439">More...</a><br /></td></tr>
<tr class="separator:a6d7d08f1be55837b8d6ac2a88eda3439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417e565d1c05d19a6f86eca740a65ddb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a417e565d1c05d19a6f86eca740a65ddb">vkz_acquire_next_image</a> (uint32_t pipeline_index, uint32_t *image_index)</td></tr>
<tr class="memdesc:a417e565d1c05d19a6f86eca740a65ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire next swapchain image.  <a href="vkzos_8h.html#a417e565d1c05d19a6f86eca740a65ddb">More...</a><br /></td></tr>
<tr class="separator:a417e565d1c05d19a6f86eca740a65ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5ec5e0240c41e57a376e21f0138b7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#aec5ec5e0240c41e57a376e21f0138b7b">vkz_present_next_image</a> (void)</td></tr>
<tr class="memdesc:aec5ec5e0240c41e57a376e21f0138b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Present next swapchain image (the one acquired by <a class="el" href="vkzos_8h.html#a417e565d1c05d19a6f86eca740a65ddb" title="Acquire next swapchain image.">vkz_acquire_next_image()</a>)  <a href="vkzos_8h.html#aec5ec5e0240c41e57a376e21f0138b7b">More...</a><br /></td></tr>
<tr class="separator:aec5ec5e0240c41e57a376e21f0138b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed81951fe299c55f95fbb1ae70fbdae0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#aed81951fe299c55f95fbb1ae70fbdae0">vkz_draw</a> (VkCommandBuffer *command_buffer)</td></tr>
<tr class="memdesc:aed81951fe299c55f95fbb1ae70fbdae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send draw commands (will take effect on the current pipeline image acquired by <a class="el" href="vkzos_8h.html#a417e565d1c05d19a6f86eca740a65ddb" title="Acquire next swapchain image.">vkz_acquire_next_image()</a>)  <a href="vkzos_8h.html#aed81951fe299c55f95fbb1ae70fbdae0">More...</a><br /></td></tr>
<tr class="separator:aed81951fe299c55f95fbb1ae70fbdae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ae2537eb08cab47df5f5a1cce35ff1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a09ae2537eb08cab47df5f5a1cce35ff1">vkz_create_buffer</a> (VkBuffer *buffer, VkBufferUsageFlags buffer_usage_flags, uint32_t buffer_size, VkDeviceMemory *memory, VkMemoryPropertyFlags memory_property_flags)</td></tr>
<tr class="memdesc:a09ae2537eb08cab47df5f5a1cce35ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a buffer.  <a href="vkzos_8h.html#a09ae2537eb08cab47df5f5a1cce35ff1">More...</a><br /></td></tr>
<tr class="separator:a09ae2537eb08cab47df5f5a1cce35ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea91a3686c4f42f8b66d0de599798fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#afea91a3686c4f42f8b66d0de599798fb">vkz_destroy_buffer</a> (VkBuffer buffer, VkDeviceMemory memory)</td></tr>
<tr class="memdesc:afea91a3686c4f42f8b66d0de599798fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a buffer.  <a href="vkzos_8h.html#afea91a3686c4f42f8b66d0de599798fb">More...</a><br /></td></tr>
<tr class="separator:afea91a3686c4f42f8b66d0de599798fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b073d3829c17efe01c1c69553d0698"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#ab5b073d3829c17efe01c1c69553d0698">vkz_copy_buffer</a> (VkBuffer source, VkBuffer destination, VkDeviceSize size)</td></tr>
<tr class="memdesc:ab5b073d3829c17efe01c1c69553d0698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a buffer to another.  <a href="vkzos_8h.html#ab5b073d3829c17efe01c1c69553d0698">More...</a><br /></td></tr>
<tr class="separator:ab5b073d3829c17efe01c1c69553d0698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e37b3c8700ba58dad02bd4b62896d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#ab1e37b3c8700ba58dad02bd4b62896d7">vkz_create_image</a> (VkImage *image, uint32_t image_width, uint32_t image_height, VkFormat image_format, VkImageTiling image_tiling, VkImageUsageFlags image_usage_flags, VkDeviceMemory *memory, VkMemoryPropertyFlags memory_property_flags)</td></tr>
<tr class="memdesc:ab1e37b3c8700ba58dad02bd4b62896d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan image.  <a href="vkzos_8h.html#ab1e37b3c8700ba58dad02bd4b62896d7">More...</a><br /></td></tr>
<tr class="separator:ab1e37b3c8700ba58dad02bd4b62896d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb33a657b0e89ffb7a850c8549754a7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#abb33a657b0e89ffb7a850c8549754a7a">vkz_destroy_image</a> (VkImage image, VkDeviceMemory image_memory)</td></tr>
<tr class="memdesc:abb33a657b0e89ffb7a850c8549754a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a Vulkan image.  <a href="vkzos_8h.html#abb33a657b0e89ffb7a850c8549754a7a">More...</a><br /></td></tr>
<tr class="separator:abb33a657b0e89ffb7a850c8549754a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdbfeac6539ac92107a3f6c1c150623"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#adfdbfeac6539ac92107a3f6c1c150623">vkz_transition_image_layout</a> (VkImage image, VkFormat format, VkImageLayout old_layout, VkImageLayout new_layout)</td></tr>
<tr class="memdesc:adfdbfeac6539ac92107a3f6c1c150623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition the layout of a Vulkan image.  <a href="vkzos_8h.html#adfdbfeac6539ac92107a3f6c1c150623">More...</a><br /></td></tr>
<tr class="separator:adfdbfeac6539ac92107a3f6c1c150623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecab3e345334428d706db7d580f21a41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#aecab3e345334428d706db7d580f21a41">vkz_copy_buffer_to_image</a> (VkBuffer buffer, VkImage image, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:aecab3e345334428d706db7d580f21a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a buffer to an image.  <a href="vkzos_8h.html#aecab3e345334428d706db7d580f21a41">More...</a><br /></td></tr>
<tr class="separator:aecab3e345334428d706db7d580f21a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301aaab89cb6be938c1ed8f5e65eef59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a301aaab89cb6be938c1ed8f5e65eef59">vkz_create_image_view</a> (VkImageView *image_view, VkImage image, VkFormat format, VkImageAspectFlags aspect_flags)</td></tr>
<tr class="memdesc:a301aaab89cb6be938c1ed8f5e65eef59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan image view.  <a href="vkzos_8h.html#a301aaab89cb6be938c1ed8f5e65eef59">More...</a><br /></td></tr>
<tr class="separator:a301aaab89cb6be938c1ed8f5e65eef59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e904ed44828a62e2e250d7d8c69681c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a2e904ed44828a62e2e250d7d8c69681c">vkz_create_sampler</a> (VkSampler *sampler)</td></tr>
<tr class="memdesc:a2e904ed44828a62e2e250d7d8c69681c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Vulkan sampler.  <a href="vkzos_8h.html#a2e904ed44828a62e2e250d7d8c69681c">More...</a><br /></td></tr>
<tr class="separator:a2e904ed44828a62e2e250d7d8c69681c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a11b944ee16fd1f6b7288d81689570"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a07a11b944ee16fd1f6b7288d81689570">vkz_shutdown</a> (void)</td></tr>
<tr class="memdesc:a07a11b944ee16fd1f6b7288d81689570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup the memory, destroy any debug callbacks, as well as the logical device and the Vulkan instance.  <a href="vkzos_8h.html#a07a11b944ee16fd1f6b7288d81689570">More...</a><br /></td></tr>
<tr class="separator:a07a11b944ee16fd1f6b7288d81689570"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad0279a86c08897a13cc85b0c35b5a72e"><td class="memItemLeft" align="right" valign="top"><a id="ad0279a86c08897a13cc85b0c35b5a72e"></a>
VkInstance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#ad0279a86c08897a13cc85b0c35b5a72e">vkz_instance</a></td></tr>
<tr class="memdesc:ad0279a86c08897a13cc85b0c35b5a72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Vulkan instance. <br /></td></tr>
<tr class="separator:ad0279a86c08897a13cc85b0c35b5a72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d51c9f83acb388c4f9dbf357e74d07"><td class="memItemLeft" align="right" valign="top"><a id="ae0d51c9f83acb388c4f9dbf357e74d07"></a>
VkSurfaceKHR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#ae0d51c9f83acb388c4f9dbf357e74d07">vkz_surface</a></td></tr>
<tr class="memdesc:ae0d51c9f83acb388c4f9dbf357e74d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">The surface on which graphics will be presented. <br /></td></tr>
<tr class="separator:ae0d51c9f83acb388c4f9dbf357e74d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae613ef4aa20d05a6c7a3246ceaeb8e5a"><td class="memItemLeft" align="right" valign="top"><a id="ae613ef4aa20d05a6c7a3246ceaeb8e5a"></a>
VkPhysicalDevice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#ae613ef4aa20d05a6c7a3246ceaeb8e5a">vkz_physical_device</a></td></tr>
<tr class="memdesc:ae613ef4aa20d05a6c7a3246ceaeb8e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The physical device that is selected <a class="el" href="vkzos_8h.html#a3d928e1d6442c9aec817f5562a86c905" title="Initialise. Internally this means create physical device, select queue families and create logical de...">vkz_init()</a>. <br /></td></tr>
<tr class="separator:ae613ef4aa20d05a6c7a3246ceaeb8e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a8dd4066651194d34a73f25c9cc3b8"><td class="memItemLeft" align="right" valign="top"><a id="a81a8dd4066651194d34a73f25c9cc3b8"></a>
VkDevice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a81a8dd4066651194d34a73f25c9cc3b8">vkz_logical_device</a></td></tr>
<tr class="memdesc:a81a8dd4066651194d34a73f25c9cc3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical device that is created by <a class="el" href="vkzos_8h.html#a3d928e1d6442c9aec817f5562a86c905" title="Initialise. Internally this means create physical device, select queue families and create logical de...">vkz_init()</a>. <br /></td></tr>
<tr class="separator:a81a8dd4066651194d34a73f25c9cc3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497cab2d9e5c7ae0173b26e788efd051"><td class="memItemLeft" align="right" valign="top"><a id="a497cab2d9e5c7ae0173b26e788efd051"></a>
VkPipelineLayout *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a497cab2d9e5c7ae0173b26e788efd051">vkz_pipeline_layout</a></td></tr>
<tr class="memdesc:a497cab2d9e5c7ae0173b26e788efd051"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pipeline layouts, one for each pipeline created. <br /></td></tr>
<tr class="separator:a497cab2d9e5c7ae0173b26e788efd051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48c41837c8f16590c36c8b2133f8acd"><td class="memItemLeft" align="right" valign="top"><a id="ac48c41837c8f16590c36c8b2133f8acd"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#ac48c41837c8f16590c36c8b2133f8acd">vkz_swapchain_image_count</a></td></tr>
<tr class="memdesc:ac48c41837c8f16590c36c8b2133f8acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of images in the swapchain, set by <a class="el" href="vkzos_8h.html#ae6b5b1afb79d82d63aad27004a1ec042" title="Create the swapchain that will be used. This will also create the associated image views.">vkz_create_swapchain()</a>. <br /></td></tr>
<tr class="separator:ac48c41837c8f16590c36c8b2133f8acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15aa36bf5aaa3c4e44b236c9eb98e634"><td class="memItemLeft" align="right" valign="top"><a id="a15aa36bf5aaa3c4e44b236c9eb98e634"></a>
VkClearColorValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vkzos_8h.html#a15aa36bf5aaa3c4e44b236c9eb98e634">vkz_clear_colour</a></td></tr>
<tr class="memdesc:a15aa36bf5aaa3c4e44b236c9eb98e634"><td class="mdescLeft">&#160;</td><td class="mdescRight">The colour used to clear the screen. <br /></td></tr>
<tr class="separator:a15aa36bf5aaa3c4e44b236c9eb98e634"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Vulkan helper functions. </p>
<p>Created on: 2018/05/01 Author: Dimitri Kourkoulis License: BSD 3-Clause License (see LICENSE file) </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a417e565d1c05d19a6f86eca740a65ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417e565d1c05d19a6f86eca740a65ddb">&#9670;&nbsp;</a></span>vkz_acquire_next_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_acquire_next_image </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pipeline_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>image_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire next swapchain image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline_index</td><td>The index of the pipeline </td></tr>
    <tr><td class="paramname">image_index</td><td>The index of the acquired swapchain image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="adf0e37831055659987cce0d826d24ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0e37831055659987cce0d826d24ebb">&#9670;&nbsp;</a></span>vkz_begin_draw_command_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_begin_draw_command_buffer </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer *&#160;</td>
          <td class="paramname"><em>command_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin creating a drawing command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>Pointer to the command buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a00cc3b9c1143cf9c6b94326267593646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cc3b9c1143cf9c6b94326267593646">&#9670;&nbsp;</a></span>vkz_bind_pipeline_to_command_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_bind_pipeline_to_command_buffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pipeline_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkCommandBuffer *&#160;</td>
          <td class="paramname"><em>command_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a pipeline to a command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline_index</td><td>The index of the pipeline </td></tr>
    <tr><td class="paramname">command_buffer</td><td>Pointer to the command buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="ab5b073d3829c17efe01c1c69553d0698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b073d3829c17efe01c1c69553d0698">&#9670;&nbsp;</a></span>vkz_copy_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_copy_buffer </td>
          <td>(</td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a buffer to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source buffer </td></tr>
    <tr><td class="paramname">destination</td><td>The destination buffer </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer to be copied, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="aecab3e345334428d706db7d580f21a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecab3e345334428d706db7d580f21a41">&#9670;&nbsp;</a></span>vkz_copy_buffer_to_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_copy_buffer_to_image </td>
          <td>(</td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a buffer to an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer </td></tr>
    <tr><td class="paramname">image</td><td>The image </td></tr>
    <tr><td class="paramname">width</td><td>The width of the image </td></tr>
    <tr><td class="paramname">height</td><td>The height of the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a09ae2537eb08cab47df5f5a1cce35ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ae2537eb08cab47df5f5a1cce35ff1">&#9670;&nbsp;</a></span>vkz_create_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_create_buffer </td>
          <td>(</td>
          <td class="paramtype">VkBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBufferUsageFlags&#160;</td>
          <td class="paramname"><em>buffer_usage_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceMemory *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>memory_property_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Variable in which to store the buffer </td></tr>
    <tr><td class="paramname">buffer_usage_flags</td><td>Vulkan usage flags for the buffer </td></tr>
    <tr><td class="paramname">buffer_size</td><td>The size of the buffer, in bytes </td></tr>
    <tr><td class="paramname">memory</td><td>The GPU memory reserved for the buffer </td></tr>
    <tr><td class="paramname">memory_property_flags</td><td>Vulkan properties of the reserved memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a8bc83914d1f7c03521b12629f0a99863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc83914d1f7c03521b12629f0a99863">&#9670;&nbsp;</a></span>vkz_create_depth_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_create_depth_image </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the image used for depth testing. This function must be called right after <a class="el" href="vkzos_8h.html#ae6b5b1afb79d82d63aad27004a1ec042" title="Create the swapchain that will be used. This will also create the associated image views.">vkz_create_swapchain()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="ab1e37b3c8700ba58dad02bd4b62896d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e37b3c8700ba58dad02bd4b62896d7">&#9670;&nbsp;</a></span>vkz_create_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_create_image </td>
          <td>(</td>
          <td class="paramtype">VkImage *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>image_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>image_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>image_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageTiling&#160;</td>
          <td class="paramname"><em>image_tiling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageUsageFlags&#160;</td>
          <td class="paramname"><em>image_usage_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceMemory *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>memory_property_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Variable in which to store the image </td></tr>
    <tr><td class="paramname">image_width</td><td>The width of the image </td></tr>
    <tr><td class="paramname">image_height</td><td>The height of the image </td></tr>
    <tr><td class="paramname">image_format</td><td>The format of the image </td></tr>
    <tr><td class="paramname">image_tiling</td><td>The tiling of the image </td></tr>
    <tr><td class="paramname">image_usage_flags</td><td>The usage flags of the image </td></tr>
    <tr><td class="paramname">memory</td><td>The GPU memory reserved for the image </td></tr>
    <tr><td class="paramname">memory_property_flags</td><td>Vulkan properties of the reserved memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a301aaab89cb6be938c1ed8f5e65eef59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301aaab89cb6be938c1ed8f5e65eef59">&#9670;&nbsp;</a></span>vkz_create_image_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_create_image_view </td>
          <td>(</td>
          <td class="paramtype">VkImageView *&#160;</td>
          <td class="paramname"><em>image_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlags&#160;</td>
          <td class="paramname"><em>aspect_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan image view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_view</td><td>The image view to be created </td></tr>
    <tr><td class="paramname">image</td><td>The image for which the image view will be created </td></tr>
    <tr><td class="paramname">format</td><td>The image view format </td></tr>
    <tr><td class="paramname">aspect_flags</td><td>The aspect flags (mask) e.g. VK_IMAGE_ASPECT_COLOR_BIT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="af6e9b9e46e4bddcd0b7076bfbbfbb815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e9b9e46e4bddcd0b7076bfbbfbb815">&#9670;&nbsp;</a></span>vkz_create_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_create_instance </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>application_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>enabled_extension_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>enabled_extension_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a vulkan instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">application_name</td><td>The name of the application that will be using Vulkan </td></tr>
    <tr><td class="paramname">enabled_extension_names</td><td>Names of extensions used </td></tr>
    <tr><td class="paramname">enabled_extension_count</td><td>Number of extensions used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a784cb3ffcb643a79ad4f88ffc9a8a831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784cb3ffcb643a79ad4f88ffc9a8a831">&#9670;&nbsp;</a></span>vkz_create_pipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_create_pipeline </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vertex_shader_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fragment_shader_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(VkPipelineVertexInputStateCreateInfo *)&#160;</td>
          <td class="paramname"><em>set_input_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(VkPipelineLayoutCreateInfo *)&#160;</td>
          <td class="paramname"><em>set_pipeline_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pipeline. This will also create associated Vulkan objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_shader_path</td><td>The path to the SPV file for the vertex shader that will be used in the pipeline. </td></tr>
    <tr><td class="paramname">fragment_shader_path</td><td>The path to the SPV file for the fragment shader that will be used in the pipeline. </td></tr>
    <tr><td class="paramname">set_input_state</td><td>Callback function, allowing e.g. the addition of information on buffers that will be used by the pipeline (vertex, uniform) before the pipeline is created. If there is no such information to be added, NULL should be passed here. </td></tr>
    <tr><td class="paramname">set_pipeline_layout</td><td>Callback function, allowing e.g. the addition of information on descriptors that will be used by the pipeline before the pipeline is created. If there is no such information to be added, NULL should be passed here. </td></tr>
    <tr><td class="paramname">index</td><td>If 100 is passed here, a new "slot" will be used for the pipeline and returned via the same variable. If not, the pipeline will be created over a previously deleted pipeline at the index position of the internal array containing pipelines. In that case, the shader path parameters will be ignored, because the previously used shaders will be reused. Also in that case the callback functions parameters will be ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a2e904ed44828a62e2e250d7d8c69681c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e904ed44828a62e2e250d7d8c69681c">&#9670;&nbsp;</a></span>vkz_create_sampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_create_sampler </td>
          <td>(</td>
          <td class="paramtype">VkSampler *&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Vulkan sampler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td>The sampler to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="ae6b5b1afb79d82d63aad27004a1ec042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b5b1afb79d82d63aad27004a1ec042">&#9670;&nbsp;</a></span>vkz_create_swapchain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_create_swapchain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>with_image_sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the swapchain that will be used. This will also create the associated image views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">with_image_sampler</td><td>1 If an image sampler will be used, 0 otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a5d2de1d94e33394ca1c2fb6e7323e778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2de1d94e33394ca1c2fb6e7323e778">&#9670;&nbsp;</a></span>vkz_create_sync_objects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_create_sync_objects </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create sync objects. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="afea91a3686c4f42f8b66d0de599798fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea91a3686c4f42f8b66d0de599798fb">&#9670;&nbsp;</a></span>vkz_destroy_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_destroy_buffer </td>
          <td>(</td>
          <td class="paramtype">VkBuffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceMemory&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to be destroyed </td></tr>
    <tr><td class="paramname">memory</td><td>The GPU memory previously reserved for the buffer, to be released </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a47c84cdbe4649348893435572096578c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c84cdbe4649348893435572096578c">&#9670;&nbsp;</a></span>vkz_destroy_depth_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_destroy_depth_image </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the image used for depth testing. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a67e75c0f91918e52ec1b69904d68f231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e75c0f91918e52ec1b69904d68f231">&#9670;&nbsp;</a></span>vkz_destroy_draw_command_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_destroy_draw_command_buffer </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer *&#160;</td>
          <td class="paramname"><em>command_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>Pointer to the command buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="abb33a657b0e89ffb7a850c8549754a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb33a657b0e89ffb7a850c8549754a7a">&#9670;&nbsp;</a></span>vkz_destroy_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_destroy_image </td>
          <td>(</td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceMemory&#160;</td>
          <td class="paramname"><em>image_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a Vulkan image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image to be destroyed </td></tr>
    <tr><td class="paramname">image_memory</td><td>The GPU memory previously reserved for the image, to be released </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="ad7fdc47fa92ad88c0d7ba8f37dc6da31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fdc47fa92ad88c0d7ba8f37dc6da31">&#9670;&nbsp;</a></span>vkz_destroy_swapchain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_destroy_swapchain </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the swapchain. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a1ca1ef6f12a537273666f109e943a778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca1ef6f12a537273666f109e943a778">&#9670;&nbsp;</a></span>vkz_destroy_sync_objects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_destroy_sync_objects </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy sync objects. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="aed81951fe299c55f95fbb1ae70fbdae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed81951fe299c55f95fbb1ae70fbdae0">&#9670;&nbsp;</a></span>vkz_draw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_draw </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer *&#160;</td>
          <td class="paramname"><em>command_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send draw commands (will take effect on the current pipeline image acquired by <a class="el" href="vkzos_8h.html#a417e565d1c05d19a6f86eca740a65ddb" title="Acquire next swapchain image.">vkz_acquire_next_image()</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>Pointer to the command buffer containing the commands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a088475389445522349c7fe98e97d4e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088475389445522349c7fe98e97d4e40">&#9670;&nbsp;</a></span>vkz_end_draw_command_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_end_draw_command_buffer </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer *&#160;</td>
          <td class="paramname"><em>command_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish recording a command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command_buffer</td><td>Pointer to the command buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a3d928e1d6442c9aec817f5562a86c905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d928e1d6442c9aec817f5562a86c905">&#9670;&nbsp;</a></span>vkz_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise. Internally this means create physical device, select queue families and create logical device. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="aec5ec5e0240c41e57a376e21f0138b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5ec5e0240c41e57a376e21f0138b7b">&#9670;&nbsp;</a></span>vkz_present_next_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_present_next_image </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Present next swapchain image (the one acquired by <a class="el" href="vkzos_8h.html#a417e565d1c05d19a6f86eca740a65ddb" title="Acquire next swapchain image.">vkz_acquire_next_image()</a>) </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a6d7d08f1be55837b8d6ac2a88eda3439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7d08f1be55837b8d6ac2a88eda3439">&#9670;&nbsp;</a></span>vkz_recreate_pipelines_and_swapchain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_recreate_pipelines_and_swapchain </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recreate the swapchain and the pipelines. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a0195411e2f1dc0e86ea9e288cece7dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0195411e2f1dc0e86ea9e288cece7dbb">&#9670;&nbsp;</a></span>vkz_set_width_height()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_set_width_height </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set width and height for all rendering calculations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The new width </td></tr>
    <tr><td class="paramname">height</td><td>The new height </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="a07a11b944ee16fd1f6b7288d81689570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a11b944ee16fd1f6b7288d81689570">&#9670;&nbsp;</a></span>vkz_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanup the memory, destroy any debug callbacks, as well as the logical device and the Vulkan instance. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
<a id="adfdbfeac6539ac92107a3f6c1c150623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdbfeac6539ac92107a3f6c1c150623">&#9670;&nbsp;</a></span>vkz_transition_image_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vkz_transition_image_layout </td>
          <td>(</td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>old_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>new_layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition the layout of a Vulkan image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The Vulkan image </td></tr>
    <tr><td class="paramname">format</td><td>The image format </td></tr>
    <tr><td class="paramname">old_layout</td><td>The old layout </td></tr>
    <tr><td class="paramname">new_layout</td><td>The new layout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
