<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The small3d library: small3d::Renderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_s.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The small3d library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesmall3d.html">small3d</a></li><li class="navelem"><a class="el" href="classsmall3d_1_1_renderer.html">Renderer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classsmall3d_1_1_renderer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">small3d::Renderer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The renderer (Vulkan). There is an OpenGL renderer class with the same interface in the opengl directory. It is picked up automatically by the project build scripts and build configuration when launched with the appropriate parameters.  
 <a href="classsmall3d_1_1_renderer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_renderer_8hpp_source.html">Renderer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a431380a4b28abb9a14c02c4535e49a1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a431380a4b28abb9a14c02c4535e49a1b">setCameraRotation</a> (const glm::vec3 &amp;rotation)</td></tr>
<tr class="memdesc:a431380a4b28abb9a14c02c4535e49a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Set the rotation of the camera  <a href="classsmall3d_1_1_renderer.html#a431380a4b28abb9a14c02c4535e49a1b">More...</a><br /></td></tr>
<tr class="separator:a431380a4b28abb9a14c02c4535e49a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88086d55064237f48d33d6366df58eaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a88086d55064237f48d33d6366df58eaf">rotateCamera</a> (const glm::vec3 &amp;rotation)</td></tr>
<tr class="memdesc:a88086d55064237f48d33d6366df58eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Modify the rotation of the camera  <a href="classsmall3d_1_1_renderer.html#a88086d55064237f48d33d6366df58eaf">More...</a><br /></td></tr>
<tr class="separator:a88086d55064237f48d33d6366df58eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab895333eea762ecfab8fb2e902b2862e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#ab895333eea762ecfab8fb2e902b2862e">setCameraTransformation</a> (const glm::mat4x4 &amp;transformation)</td></tr>
<tr class="memdesc:ab895333eea762ecfab8fb2e902b2862e"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Set the camera transformation matrix  <a href="classsmall3d_1_1_renderer.html#ab895333eea762ecfab8fb2e902b2862e">More...</a><br /></td></tr>
<tr class="separator:ab895333eea762ecfab8fb2e902b2862e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4560bec0819d5f5c4b83500659e5fda"><td class="memItemLeft" align="right" valign="top">const glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#ae4560bec0819d5f5c4b83500659e5fda">getCameraOrientation</a> () const</td></tr>
<tr class="memdesc:ae4560bec0819d5f5c4b83500659e5fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Get the orientation of the camera  <a href="classsmall3d_1_1_renderer.html#ae4560bec0819d5f5c4b83500659e5fda">More...</a><br /></td></tr>
<tr class="separator:ae4560bec0819d5f5c4b83500659e5fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8a29f7eb8e71597aac9f4ccfbb06f8"><td class="memItemLeft" align="right" valign="top">const glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a9c8a29f7eb8e71597aac9f4ccfbb06f8">getCameraRotation</a> () const</td></tr>
<tr class="memdesc:a9c8a29f7eb8e71597aac9f4ccfbb06f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Get the rotation of the camera by transformation matrix  <a href="classsmall3d_1_1_renderer.html#a9c8a29f7eb8e71597aac9f4ccfbb06f8">More...</a><br /></td></tr>
<tr class="separator:a9c8a29f7eb8e71597aac9f4ccfbb06f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657c6be0841a2f8b938c1fc9ef857a84"><td class="memItemLeft" align="right" valign="top">const glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a657c6be0841a2f8b938c1fc9ef857a84">getCameraRotationXYZ</a> () const</td></tr>
<tr class="memdesc:a657c6be0841a2f8b938c1fc9ef857a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Get the rotation of the camera in x, y, z representation. This will NOT work if the rotation was set via the setRotation(mat4x4) function.  <a href="classsmall3d_1_1_renderer.html#a657c6be0841a2f8b938c1fc9ef857a84">More...</a><br /></td></tr>
<tr class="separator:a657c6be0841a2f8b938c1fc9ef857a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8816c9329595bbe489131cc2bf4495"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#adc8816c9329595bbe489131cc2bf4495">getScreenWidth</a> ()</td></tr>
<tr class="memdesc:adc8816c9329595bbe489131cc2bf4495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real screen width.  <a href="classsmall3d_1_1_renderer.html#adc8816c9329595bbe489131cc2bf4495">More...</a><br /></td></tr>
<tr class="separator:adc8816c9329595bbe489131cc2bf4495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed406b218be5e972d7566a321f893e82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#aed406b218be5e972d7566a321f893e82">getScreenHeight</a> ()</td></tr>
<tr class="memdesc:aed406b218be5e972d7566a321f893e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real screen height.  <a href="classsmall3d_1_1_renderer.html#aed406b218be5e972d7566a321f893e82">More...</a><br /></td></tr>
<tr class="separator:aed406b218be5e972d7566a321f893e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32163440246ed8ea5016e15dfc781775"><td class="memItemLeft" align="right" valign="top"><a id="a32163440246ed8ea5016e15dfc781775"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a32163440246ed8ea5016e15dfc781775">~Renderer</a> ()</td></tr>
<tr class="memdesc:a32163440246ed8ea5016e15dfc781775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a32163440246ed8ea5016e15dfc781775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2065e4645034d538e5bbd40cd5fa3a50"><td class="memItemLeft" align="right" valign="top"><a id="a2065e4645034d538e5bbd40cd5fa3a50"></a>
GLFWwindow *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a2065e4645034d538e5bbd40cd5fa3a50">getWindow</a> () const</td></tr>
<tr class="memdesc:a2065e4645034d538e5bbd40cd5fa3a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GLFW window object, associated with the <a class="el" href="classsmall3d_1_1_renderer.html" title="The renderer (Vulkan). There is an OpenGL renderer class with the same interface in the opengl direct...">Renderer</a>. <br /></td></tr>
<tr class="separator:a2065e4645034d538e5bbd40cd5fa3a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fc446b4ee64fbb831aa8f08a54dbdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#aa3fc446b4ee64fbb831aa8f08a54dbdc">generateTexture</a> (const std::string &amp;name, const <a class="el" href="classsmall3d_1_1_image.html">Image</a> &amp;image)</td></tr>
<tr class="memdesc:aa3fc446b4ee64fbb831aa8f08a54dbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a texture on the GPU from the given image.  <a href="classsmall3d_1_1_renderer.html#aa3fc446b4ee64fbb831aa8f08a54dbdc">More...</a><br /></td></tr>
<tr class="separator:aa3fc446b4ee64fbb831aa8f08a54dbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6b2ba40d5f89691d03ebebd52aaabb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a9e6b2ba40d5f89691d03ebebd52aaabb">generateTexture</a> (const std::string &amp;name, const std::string &amp;text, const glm::vec3 &amp;colour, const int fontSize=48, const std::string &amp;fontPath=DEFAULT_FONT_PATH, const bool replace=true)</td></tr>
<tr class="memdesc:a9e6b2ba40d5f89691d03ebebd52aaabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a texture on the GPU that contains the given text.  <a href="classsmall3d_1_1_renderer.html#a9e6b2ba40d5f89691d03ebebd52aaabb">More...</a><br /></td></tr>
<tr class="separator:a9e6b2ba40d5f89691d03ebebd52aaabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3edaca7521e526b5cf311ed4c541452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#aa3edaca7521e526b5cf311ed4c541452">deleteTexture</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa3edaca7521e526b5cf311ed4c541452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the texture indicated by the given name.  <a href="classsmall3d_1_1_renderer.html#aa3edaca7521e526b5cf311ed4c541452">More...</a><br /></td></tr>
<tr class="separator:aa3edaca7521e526b5cf311ed4c541452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa5ae15a3a21aaf43bbce93b5d3cdd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#acaa5ae15a3a21aaf43bbce93b5d3cdd7">createRectangle</a> (<a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;rect, const glm::vec3 &amp;topLeft, const glm::vec3 &amp;bottomRight)</td></tr>
<tr class="memdesc:acaa5ae15a3a21aaf43bbce93b5d3cdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a> object with a rectangle stretching between the given coordinates.  <a href="classsmall3d_1_1_renderer.html#acaa5ae15a3a21aaf43bbce93b5d3cdd7">More...</a><br /></td></tr>
<tr class="separator:acaa5ae15a3a21aaf43bbce93b5d3cdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e18337a9556fe4f1c069529547de5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#aa7e18337a9556fe4f1c069529547de5b">render</a> (<a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;model, const glm::vec3 &amp;position, const glm::vec3 &amp;rotation, const glm::vec4 &amp;colour, const std::string &amp;textureName=&quot;&quot;, const bool perspective=true)</td></tr>
<tr class="memdesc:aa7e18337a9556fe4f1c069529547de5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a>.  <a href="classsmall3d_1_1_renderer.html#aa7e18337a9556fe4f1c069529547de5b">More...</a><br /></td></tr>
<tr class="separator:aa7e18337a9556fe4f1c069529547de5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe6cfb0401d41149db64a359245cd2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#afbe6cfb0401d41149db64a359245cd2a">render</a> (<a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;model, const glm::vec3 &amp;position, const glm::vec3 &amp;rotation, const std::string &amp;textureName)</td></tr>
<tr class="memdesc:afbe6cfb0401d41149db64a359245cd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a>.  <a href="classsmall3d_1_1_renderer.html#afbe6cfb0401d41149db64a359245cd2a">More...</a><br /></td></tr>
<tr class="separator:afbe6cfb0401d41149db64a359245cd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80251efe4a1a6caf037914b2155215b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a80251efe4a1a6caf037914b2155215b4">render</a> (<a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;model, const glm::vec3 &amp;position, const glm::mat4x4 &amp;rotation, const glm::vec4 &amp;colour, const std::string &amp;textureName=&quot;&quot;, const bool perspective=true)</td></tr>
<tr class="memdesc:a80251efe4a1a6caf037914b2155215b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a>.  <a href="classsmall3d_1_1_renderer.html#a80251efe4a1a6caf037914b2155215b4">More...</a><br /></td></tr>
<tr class="separator:a80251efe4a1a6caf037914b2155215b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8450dbd3580f993fd2bdf6465e5d74e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#ac8450dbd3580f993fd2bdf6465e5d74e">render</a> (<a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;model, const glm::vec3 &amp;position, const glm::mat4x4 &amp;rotation, const std::string &amp;textureName)</td></tr>
<tr class="memdesc:ac8450dbd3580f993fd2bdf6465e5d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a>.  <a href="classsmall3d_1_1_renderer.html#ac8450dbd3580f993fd2bdf6465e5d74e">More...</a><br /></td></tr>
<tr class="separator:ac8450dbd3580f993fd2bdf6465e5d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5197bb14286d72ded6397ab1f5d1e9be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a5197bb14286d72ded6397ab1f5d1e9be">render</a> (<a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;model, const std::string &amp;textureName, const bool perspective=true)</td></tr>
<tr class="memdesc:a5197bb14286d72ded6397ab1f5d1e9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a>.  <a href="classsmall3d_1_1_renderer.html#a5197bb14286d72ded6397ab1f5d1e9be">More...</a><br /></td></tr>
<tr class="separator:a5197bb14286d72ded6397ab1f5d1e9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604f156f1eba38959ec1ef7f0f18b9d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a604f156f1eba38959ec1ef7f0f18b9d7">render</a> (<a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;model, const glm::vec4 &amp;colour, const bool perspective=true)</td></tr>
<tr class="memdesc:a604f156f1eba38959ec1ef7f0f18b9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a>.  <a href="classsmall3d_1_1_renderer.html#a604f156f1eba38959ec1ef7f0f18b9d7">More...</a><br /></td></tr>
<tr class="separator:a604f156f1eba38959ec1ef7f0f18b9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2369b6490ee51256c2b58490cced0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a3e2369b6490ee51256c2b58490cced0a">render</a> (<a class="el" href="classsmall3d_1_1_scene_object.html">SceneObject</a> &amp;sceneObject, const glm::vec4 &amp;colour)</td></tr>
<tr class="memdesc:a3e2369b6490ee51256c2b58490cced0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a <a class="el" href="classsmall3d_1_1_scene_object.html" title="An object that appears on the 3D scene. It is made up of a Model, together with information for posit...">SceneObject</a>.  <a href="classsmall3d_1_1_renderer.html#a3e2369b6490ee51256c2b58490cced0a">More...</a><br /></td></tr>
<tr class="separator:a3e2369b6490ee51256c2b58490cced0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad10fd0f0546566c6022931b6b54bed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a8ad10fd0f0546566c6022931b6b54bed">render</a> (<a class="el" href="classsmall3d_1_1_scene_object.html">SceneObject</a> &amp;sceneObject, const std::string &amp;textureName)</td></tr>
<tr class="memdesc:a8ad10fd0f0546566c6022931b6b54bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a <a class="el" href="classsmall3d_1_1_scene_object.html" title="An object that appears on the 3D scene. It is made up of a Model, together with information for posit...">SceneObject</a>.  <a href="classsmall3d_1_1_renderer.html#a8ad10fd0f0546566c6022931b6b54bed">More...</a><br /></td></tr>
<tr class="separator:a8ad10fd0f0546566c6022931b6b54bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ab3a6ebf64fe75c9121d06637d8ee8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a40ab3a6ebf64fe75c9121d06637d8ee8">clearBuffers</a> (<a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;model)</td></tr>
<tr class="memdesc:a40ab3a6ebf64fe75c9121d06637d8ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a> from the GPU buffers (the object itself remains intact).  <a href="classsmall3d_1_1_renderer.html#a40ab3a6ebf64fe75c9121d06637d8ee8">More...</a><br /></td></tr>
<tr class="separator:a40ab3a6ebf64fe75c9121d06637d8ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2f6135159d392f38175fc8a55c186d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a6e2f6135159d392f38175fc8a55c186d">clearBuffers</a> (<a class="el" href="classsmall3d_1_1_scene_object.html">SceneObject</a> &amp;sceneObject)</td></tr>
<tr class="memdesc:a6e2f6135159d392f38175fc8a55c186d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear an <a class="el" href="classsmall3d_1_1_scene_object.html" title="An object that appears on the 3D scene. It is made up of a Model, together with information for posit...">SceneObject</a> (multiple models) from the GPU buffers (the <a class="el" href="classsmall3d_1_1_scene_object.html" title="An object that appears on the 3D scene. It is made up of a Model, together with information for posit...">SceneObject</a> itself remains intact).  <a href="classsmall3d_1_1_renderer.html#a6e2f6135159d392f38175fc8a55c186d">More...</a><br /></td></tr>
<tr class="separator:a6e2f6135159d392f38175fc8a55c186d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68576dfc33356d43722e83fadec55f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#ab68576dfc33356d43722e83fadec55f4">setBackgroundColour</a> (const glm::vec4 &amp;colour)</td></tr>
<tr class="memdesc:ab68576dfc33356d43722e83fadec55f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the background colour of the screen.  <a href="classsmall3d_1_1_renderer.html#ab68576dfc33356d43722e83fadec55f4">More...</a><br /></td></tr>
<tr class="separator:ab68576dfc33356d43722e83fadec55f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc83f2aaaf3f41f35e99c1eabc6ac98"><td class="memItemLeft" align="right" valign="top"><a id="acdc83f2aaaf3f41f35e99c1eabc6ac98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#acdc83f2aaaf3f41f35e99c1eabc6ac98">swapBuffers</a> ()</td></tr>
<tr class="memdesc:acdc83f2aaaf3f41f35e99c1eabc6ac98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the buffers. <br /></td></tr>
<tr class="separator:acdc83f2aaaf3f41f35e99c1eabc6ac98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeade4469aab5489c7a7a1c5755653f8"><td class="memItemLeft" align="right" valign="top"><a id="adeade4469aab5489c7a7a1c5755653f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#adeade4469aab5489c7a7a1c5755653f8">setupVulkan</a> ()</td></tr>
<tr class="memdesc:adeade4469aab5489c7a7a1c5755653f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the Vulkan. This is called by the constructor and used internally. Normally there is no need to invoke it, appart from when an application runs on a mobile platform, in which case it can be useful to call destroyVulkan when the app loses focus and then setupVulkan when it regains it. <br /></td></tr>
<tr class="separator:adeade4469aab5489c7a7a1c5755653f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5de0802d1fd020a118db1852ea6e6b"><td class="memItemLeft" align="right" valign="top"><a id="a5a5de0802d1fd020a118db1852ea6e6b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a5a5de0802d1fd020a118db1852ea6e6b">destroyVulkan</a> ()</td></tr>
<tr class="memdesc:a5a5de0802d1fd020a118db1852ea6e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy Vulkan. This is is called by the destructor and used internally. Normally there is no need to invoke it, appart from when an application runs on a mobile platform, in which case it can be useful to call destroyVulkan when the app loses focus and then setupVulkan when it regains it. <br /></td></tr>
<tr class="separator:a5a5de0802d1fd020a118db1852ea6e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe22353fdbf54f36f8dedb607ab9c74"><td class="memItemLeft" align="right" valign="top"><a id="afbe22353fdbf54f36f8dedb607ab9c74"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Renderer</b> (<a class="el" href="classsmall3d_1_1_renderer.html">Renderer</a> const &amp;)=delete</td></tr>
<tr class="separator:afbe22353fdbf54f36f8dedb607ab9c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb0bdcb836c4416a9626478db877f69"><td class="memItemLeft" align="right" valign="top"><a id="a9cb0bdcb836c4416a9626478db877f69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classsmall3d_1_1_renderer.html">Renderer</a> const &amp;)=delete</td></tr>
<tr class="separator:a9cb0bdcb836c4416a9626478db877f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9403d5cfec7d422a7a02b255577bbf12"><td class="memItemLeft" align="right" valign="top"><a id="a9403d5cfec7d422a7a02b255577bbf12"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Renderer</b> (<a class="el" href="classsmall3d_1_1_renderer.html">Renderer</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a9403d5cfec7d422a7a02b255577bbf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683e7552dbed6c521f2936ed10976539"><td class="memItemLeft" align="right" valign="top"><a id="a683e7552dbed6c521f2936ed10976539"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classsmall3d_1_1_renderer.html">Renderer</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a683e7552dbed6c521f2936ed10976539"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0c081b92ef1a16188a4eaee9b689982a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsmall3d_1_1_renderer.html">Renderer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a0c081b92ef1a16188a4eaee9b689982a">getInstance</a> (const std::string &amp;windowTitle=&quot;&quot;, const int width=0, const int height=0, const float fieldOfView=0.785f, const float zNear=1.0f, const float zFar=24.0f, const std::string &amp;shadersPath=DEFAULT_SHADERS_DIR, const uint32_t objectsPerFrame=defaultObjectsPerFrame, const uint32_t objectsPerFrameInc=defaultObjectsPerFrameInc)</td></tr>
<tr class="memdesc:a0c081b92ef1a16188a4eaee9b689982a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the instance of the <a class="el" href="classsmall3d_1_1_renderer.html" title="The renderer (Vulkan). There is an OpenGL renderer class with the same interface in the opengl direct...">Renderer</a> (the <a class="el" href="classsmall3d_1_1_renderer.html" title="The renderer (Vulkan). There is an OpenGL renderer class with the same interface in the opengl direct...">Renderer</a> is a singleton).  <a href="classsmall3d_1_1_renderer.html#a0c081b92ef1a16188a4eaee9b689982a">More...</a><br /></td></tr>
<tr class="separator:a0c081b92ef1a16188a4eaee9b689982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae41ab2c06a1a2c768c5a14aafbe79868"><td class="memItemLeft" align="right" valign="top"><a id="ae41ab2c06a1a2c768c5a14aafbe79868"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#ae41ab2c06a1a2c768c5a14aafbe79868">shadowsActive</a> = false</td></tr>
<tr class="memdesc:ae41ab2c06a1a2c768c5a14aafbe79868"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Render shadows? <br /></td></tr>
<tr class="separator:ae41ab2c06a1a2c768c5a14aafbe79868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77353e63ccea1c4f33ff9cba9eb81978"><td class="memItemLeft" align="right" valign="top"><a id="a77353e63ccea1c4f33ff9cba9eb81978"></a>
glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a77353e63ccea1c4f33ff9cba9eb81978">lightDirection</a> = glm::vec3(0.0f, 0.7f, 0.3f)</td></tr>
<tr class="memdesc:a77353e63ccea1c4f33ff9cba9eb81978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector, indicating the direction of the light in the scene. It points towards a directional light source. <br /></td></tr>
<tr class="separator:a77353e63ccea1c4f33ff9cba9eb81978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405fc8a2a37c88cec17aa49641cf50af"><td class="memItemLeft" align="right" valign="top"><a id="a405fc8a2a37c88cec17aa49641cf50af"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a405fc8a2a37c88cec17aa49641cf50af">shadowSpaceSize</a> = 20.0f</td></tr>
<tr class="memdesc:a405fc8a2a37c88cec17aa49641cf50af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the shadows space (half-edge of the orthographic projection cube) <br /></td></tr>
<tr class="separator:a405fc8a2a37c88cec17aa49641cf50af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c76d273924ca89a305f694eab55ba45"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a5c76d273924ca89a305f694eab55ba45">shadowCamTransformation</a></td></tr>
<tr class="memdesc:a5c76d273924ca89a305f694eab55ba45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadow camera transformation. When tuning this for Vulkan, if using glm::lookAt, note that y up is -1.0f, but only for glm::lookAt and not for the position of the eye for example. This is because a correction is normally applied in the shaders for all Vulkan coordinates, in order to make them compatible with OpenGL, but it is not applied while mapping shadows.  <a href="classsmall3d_1_1_renderer.html#a5c76d273924ca89a305f694eab55ba45">More...</a><br /></td></tr>
<tr class="separator:a5c76d273924ca89a305f694eab55ba45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e23bfad9181afafcf6f64655698c35"><td class="memItemLeft" align="right" valign="top"><a id="a98e23bfad9181afafcf6f64655698c35"></a>
glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a98e23bfad9181afafcf6f64655698c35">cameraPosition</a> = glm::vec3(0, 0, 0)</td></tr>
<tr class="memdesc:a98e23bfad9181afafcf6f64655698c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The camera position in world space. Ignored for orthographic rendering. <br /></td></tr>
<tr class="separator:a98e23bfad9181afafcf6f64655698c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cad6462cacc418e9d470fa90677c40"><td class="memItemLeft" align="right" valign="top"><a id="a16cad6462cacc418e9d470fa90677c40"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmall3d_1_1_renderer.html#a16cad6462cacc418e9d470fa90677c40">lightIntensity</a> = 1.0f</td></tr>
<tr class="memdesc:a16cad6462cacc418e9d470fa90677c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The light intensity (set to -1.0f if no lighting is to be used). <br /></td></tr>
<tr class="separator:a16cad6462cacc418e9d470fa90677c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The renderer (Vulkan). There is an OpenGL renderer class with the same interface in the opengl directory. It is picked up automatically by the project build scripts and build configuration when launched with the appropriate parameters. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a40ab3a6ebf64fe75c9121d06637d8ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ab3a6ebf64fe75c9121d06637d8ee8">&#9670;&nbsp;</a></span>clearBuffers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::clearBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a> from the GPU buffers (the object itself remains intact). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e2f6135159d392f38175fc8a55c186d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2f6135159d392f38175fc8a55c186d">&#9670;&nbsp;</a></span>clearBuffers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::clearBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmall3d_1_1_scene_object.html">SceneObject</a> &amp;&#160;</td>
          <td class="paramname"><em>sceneObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear an <a class="el" href="classsmall3d_1_1_scene_object.html" title="An object that appears on the 3D scene. It is made up of a Model, together with information for posit...">SceneObject</a> (multiple models) from the GPU buffers (the <a class="el" href="classsmall3d_1_1_scene_object.html" title="An object that appears on the 3D scene. It is made up of a Model, together with information for posit...">SceneObject</a> itself remains intact). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneObject</td><td>The scene object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaa5ae15a3a21aaf43bbce93b5d3cdd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa5ae15a3a21aaf43bbce93b5d3cdd7">&#9670;&nbsp;</a></span>createRectangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::createRectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>topLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>bottomRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a> object with a rectangle stretching between the given coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td><a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a> object in which the rectangle data will be entered </td></tr>
    <tr><td class="paramname">topLeft</td><td>Top left corner of the rectangle </td></tr>
    <tr><td class="paramname">bottomRight</td><td>Bottom right corner of the rectangle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3edaca7521e526b5cf311ed4c541452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3edaca7521e526b5cf311ed4c541452">&#9670;&nbsp;</a></span>deleteTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::deleteTexture </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the texture indicated by the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3fc446b4ee64fbb831aa8f08a54dbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fc446b4ee64fbb831aa8f08a54dbdc">&#9670;&nbsp;</a></span>generateTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::generateTexture </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsmall3d_1_1_image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a texture on the GPU from the given image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name by which the texture will be known </td></tr>
    <tr><td class="paramname">image</td><td>The image from which the texture will be generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e6b2ba40d5f89691d03ebebd52aaabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6b2ba40d5f89691d03ebebd52aaabb">&#9670;&nbsp;</a></span>generateTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::generateTexture </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>colour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fontSize</em> = <code>48</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fontPath</em> = <code>DEFAULT_FONT_PATH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>replace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a texture on the GPU that contains the given text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name by which the texture will be known </td></tr>
    <tr><td class="paramname">text</td><td>The text that will be contained in the texture </td></tr>
    <tr><td class="paramname">colour</td><td>The colour of the text </td></tr>
    <tr><td class="paramname">fontSize</td><td>The size of the font which will be used </td></tr>
    <tr><td class="paramname">fontPath</td><td>Path to the TrueType font (.ttf) which will be used </td></tr>
    <tr><td class="paramname">replace</td><td>If true, an exception will be thrown if a texture with the same name already exists. Otherwise it will be overwritten. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4560bec0819d5f5c4b83500659e5fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4560bec0819d5f5c4b83500659e5fda">&#9670;&nbsp;</a></span>getCameraOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const glm::vec3 small3d::Renderer::getCameraOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Get the orientation of the camera </p>
<dl class="section return"><dt>Returns</dt><dd>The orientation of the camera </dd></dl>

</div>
</div>
<a id="a9c8a29f7eb8e71597aac9f4ccfbb06f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8a29f7eb8e71597aac9f4ccfbb06f8">&#9670;&nbsp;</a></span>getCameraRotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const glm::mat4x4 small3d::Renderer::getCameraRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Get the rotation of the camera by transformation matrix </p>
<dl class="section return"><dt>Returns</dt><dd>The camera tranformation matrix (this is inversed when rendering) </dd></dl>

</div>
</div>
<a id="a657c6be0841a2f8b938c1fc9ef857a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657c6be0841a2f8b938c1fc9ef857a84">&#9670;&nbsp;</a></span>getCameraRotationXYZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const glm::vec3 small3d::Renderer::getCameraRotationXYZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Get the rotation of the camera in x, y, z representation. This will NOT work if the rotation was set via the setRotation(mat4x4) function. </p>
<dl class="section return"><dt>Returns</dt><dd>The rotation in x, y, z representation (this is negated when rendering) </dd></dl>

</div>
</div>
<a id="a0c081b92ef1a16188a4eaee9b689982a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c081b92ef1a16188a4eaee9b689982a">&#9670;&nbsp;</a></span>getInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsmall3d_1_1_renderer.html">Renderer</a> &amp; small3d::Renderer::getInstance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>windowTitle</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>height</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>fieldOfView</em> = <code>0.785f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>zNear</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>zFar</em> = <code>24.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>shadersPath</em> = <code>DEFAULT_SHADERS_DIR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>objectsPerFrame</em> = <code>defaultObjectsPerFrame</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>objectsPerFrameInc</em> = <code>defaultObjectsPerFrameInc</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the instance of the <a class="el" href="classsmall3d_1_1_renderer.html" title="The renderer (Vulkan). There is an OpenGL renderer class with the same interface in the opengl direct...">Renderer</a> (the <a class="el" href="classsmall3d_1_1_renderer.html" title="The renderer (Vulkan). There is an OpenGL renderer class with the same interface in the opengl direct...">Renderer</a> is a singleton). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windowTitle</td><td>The title of the game's window </td></tr>
    <tr><td class="paramname">width</td><td>The width of the window. If width and height are not set or set to 0, the game will run in full screen mode. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the window </td></tr>
    <tr><td class="paramname">fieldOfView</td><td>Field of view in radians (angle between the top and the bottom plane of the view frustum). </td></tr>
    <tr><td class="paramname">zNear</td><td>Projection plane z coordinate (use positive value) </td></tr>
    <tr><td class="paramname">zFar</td><td>Far end of frustum z coordinate (use positive value) </td></tr>
    <tr><td class="paramname">shadersPath</td><td>The path where the shaders will be stored, relative to the application's executing directory. It defaults to the path provided by the engine, but it can be changed, so as to accommodate for executables which are going to be using it. Even though the path to the folder can be changed, the folder structure within it and the names of the shaders must remain as provided. The shader code can be changed, provided that their inputs and outputs are maintained the same. </td></tr>
    <tr><td class="paramname">objectsPerFrame</td><td>Maximum number of Models and / or SceneObjects foreseen to be rendered per frame. This is used to pre-allocate the needed memory buffers. </td></tr>
    <tr><td class="paramname">objectsPerFrameInc</td><td>Number of objects to increase number of objects per frame by, each time the latter is exceeded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classsmall3d_1_1_renderer.html" title="The renderer (Vulkan). There is an OpenGL renderer class with the same interface in the opengl direct...">Renderer</a> object. It can only be assigned to a pointer by its address (<a class="el" href="classsmall3d_1_1_renderer.html" title="The renderer (Vulkan). There is an OpenGL renderer class with the same interface in the opengl direct...">Renderer</a> *r = &amp;Renderer::getInstance(...), since declaring another <a class="el" href="classsmall3d_1_1_renderer.html" title="The renderer (Vulkan). There is an OpenGL renderer class with the same interface in the opengl direct...">Renderer</a> variable and assigning to it would invoke the default constructor, which has been deleted. </dd></dl>

</div>
</div>
<a id="aed406b218be5e972d7566a321f893e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed406b218be5e972d7566a321f893e82">&#9670;&nbsp;</a></span>getScreenHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int small3d::Renderer::getScreenHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the real screen height. </p>
<dl class="section return"><dt>Returns</dt><dd>The screen height </dd></dl>

</div>
</div>
<a id="adc8816c9329595bbe489131cc2bf4495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8816c9329595bbe489131cc2bf4495">&#9670;&nbsp;</a></span>getScreenWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int small3d::Renderer::getScreenWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the real screen width. </p>
<dl class="section return"><dt>Returns</dt><dd>The screen width </dd></dl>

</div>
</div>
<a id="a80251efe4a1a6caf037914b2155215b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80251efe4a1a6caf037914b2155215b4">&#9670;&nbsp;</a></span>render() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>colour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>textureName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>perspective</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model </td></tr>
    <tr><td class="paramname">position</td><td>The position of the model (x, y, z) </td></tr>
    <tr><td class="paramname">rotation</td><td>Rotation transformation matrix </td></tr>
    <tr><td class="paramname">colour</td><td>The colour of the model </td></tr>
    <tr><td class="paramname">textureName</td><td>The name of the texture to attach to the model (optional). The texture has to have been generated already. If this is set, the colour parameter will be ignored. </td></tr>
    <tr><td class="paramname">perspective</td><td>If true perform perspective rendering, otherwise orthographic. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8450dbd3580f993fd2bdf6465e5d74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8450dbd3580f993fd2bdf6465e5d74e">&#9670;&nbsp;</a></span>render() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model </td></tr>
    <tr><td class="paramname">position</td><td>The position of the model (x, y, z) </td></tr>
    <tr><td class="paramname">rotation</td><td>Rotation transformation matrix </td></tr>
    <tr><td class="paramname">textureName</td><td>The name of the texture to attach to the model. The texture has to have been generated already. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7e18337a9556fe4f1c069529547de5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e18337a9556fe4f1c069529547de5b">&#9670;&nbsp;</a></span>render() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>colour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>textureName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>perspective</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model </td></tr>
    <tr><td class="paramname">position</td><td>The position of the model (x, y, z) </td></tr>
    <tr><td class="paramname">rotation</td><td>Rotation (x, y, z) </td></tr>
    <tr><td class="paramname">colour</td><td>The colour of the model </td></tr>
    <tr><td class="paramname">textureName</td><td>The name of the texture to attach to the model (optional). The texture has to have been generated already. If this is set, the colour parameter will be ignored. </td></tr>
    <tr><td class="paramname">perspective</td><td>If true perform perspective rendering, otherwise orthographic. If false, the depth buffer is cleared. Do not intermingle perspective and orthographic rendering. Perform all the orthographic rendering in the end. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbe6cfb0401d41149db64a359245cd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe6cfb0401d41149db64a359245cd2a">&#9670;&nbsp;</a></span>render() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model </td></tr>
    <tr><td class="paramname">position</td><td>The position of the model (x, y, z) </td></tr>
    <tr><td class="paramname">rotation</td><td>Rotation (x, y, z) </td></tr>
    <tr><td class="paramname">textureName</td><td>The name of the texture to attach to the model. The texture has to have been generated already. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a604f156f1eba38959ec1ef7f0f18b9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604f156f1eba38959ec1ef7f0f18b9d7">&#9670;&nbsp;</a></span>render() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>colour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>perspective</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model </td></tr>
    <tr><td class="paramname">colour</td><td>The colour of the model </td></tr>
    <tr><td class="paramname">perspective</td><td>True = perspective drawing, otherwise orthographic If false, the depth buffer is cleared. Do not intermingle perspective and orthographic rendering. Perform all the orthographic rendering in the end. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5197bb14286d72ded6397ab1f5d1e9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5197bb14286d72ded6397ab1f5d1e9be">&#9670;&nbsp;</a></span>render() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmall3d_1_1_model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>perspective</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a <a class="el" href="classsmall3d_1_1_model.html" title="A 3D model. It can be loaded from a WavefrontFile or GlbFile. It can also be constructed procedurally...">Model</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model </td></tr>
    <tr><td class="paramname">textureName</td><td>The name of the texture to attach to the model. The texture has to have been generated already. </td></tr>
    <tr><td class="paramname">perspective</td><td>True = perspective drawing, otherwise orthographic If false, the depth buffer is cleared. Do not intermingle perspective and orthographic rendering. Perform all the orthographic rendering in the end. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e2369b6490ee51256c2b58490cced0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2369b6490ee51256c2b58490cced0a">&#9670;&nbsp;</a></span>render() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmall3d_1_1_scene_object.html">SceneObject</a> &amp;&#160;</td>
          <td class="paramname"><em>sceneObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>colour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a <a class="el" href="classsmall3d_1_1_scene_object.html" title="An object that appears on the 3D scene. It is made up of a Model, together with information for posit...">SceneObject</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneObject</td><td>The object </td></tr>
    <tr><td class="paramname">colour</td><td>The colour the object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ad10fd0f0546566c6022931b6b54bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad10fd0f0546566c6022931b6b54bed">&#9670;&nbsp;</a></span>render() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmall3d_1_1_scene_object.html">SceneObject</a> &amp;&#160;</td>
          <td class="paramname"><em>sceneObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render a <a class="el" href="classsmall3d_1_1_scene_object.html" title="An object that appears on the 3D scene. It is made up of a Model, together with information for posit...">SceneObject</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneObject</td><td>The object </td></tr>
    <tr><td class="paramname">textureName</td><td>The name of the texture to attach to the object. The texture has to have been generated already. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88086d55064237f48d33d6366df58eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88086d55064237f48d33d6366df58eaf">&#9670;&nbsp;</a></span>rotateCamera()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::rotateCamera </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Modify the rotation of the camera </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>The rotation to modify by (x, y, z) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab68576dfc33356d43722e83fadec55f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68576dfc33356d43722e83fadec55f4">&#9670;&nbsp;</a></span>setBackgroundColour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::setBackgroundColour </td>
          <td>(</td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>colour</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the background colour of the screen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colour</td><td>The background colour </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a431380a4b28abb9a14c02c4535e49a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431380a4b28abb9a14c02c4535e49a1b">&#9670;&nbsp;</a></span>setCameraRotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::setCameraRotation </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Set the rotation of the camera </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>The rotation (x, y, z) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab895333eea762ecfab8fb2e902b2862e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab895333eea762ecfab8fb2e902b2862e">&#9670;&nbsp;</a></span>setCameraTransformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void small3d::Renderer::setCameraTransformation </td>
          <td>(</td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>transformation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Set the camera transformation matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transformation</td><td>The tranformation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5c76d273924ca89a305f694eab55ba45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c76d273924ca89a305f694eab55ba45">&#9670;&nbsp;</a></span>shadowCamTransformation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 small3d::Renderer::shadowCamTransformation</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      glm::rotate(glm::mat4x4(1.0f), 1.57f, glm::vec3(1.0f, 0.0f, 0.0f)) * </div>
<div class="line">      glm::translate(glm::mat4x4(1.0f), glm::vec3(0.0f, -10.0f, 0.0f))</div>
</div><!-- fragment -->
<p>Shadow camera transformation. When tuning this for Vulkan, if using glm::lookAt, note that y up is -1.0f, but only for glm::lookAt and not for the position of the eye for example. This is because a correction is normally applied in the shaders for all Vulkan coordinates, in order to make them compatible with OpenGL, but it is not applied while mapping shadows. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_renderer_8hpp_source.html">Renderer.hpp</a></li>
<li>Renderer.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
