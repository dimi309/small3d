<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The small3d library: small3d::Model Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_s.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The small3d library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>small3d</b></li><li class="navelem"><a class="el" href="structsmall3d_1_1_model.html">Model</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structsmall3d_1_1_model-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">small3d::Model Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A 3D model. It can be loaded from a Wavefront file. Such a file can be exported from Blender for example (see blender.org). From its menu, select File &gt; Export &gt; Wavefront (.obj). Then from the "Export OBJ" menu, only select "Write Normals", "Triangulate Faces" and "Keep Vertex Order". The 3D model can also be constructed procedurally by code, by inserting values to the appropriate member variables.  
 <a href="structsmall3d_1_1_model.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_model_8hpp_source.html">Model.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa116b5b0c66b9e7f4dfd401ab5233a79"><td class="memItemLeft" align="right" valign="top"><a id="aa116b5b0c66b9e7f4dfd401ab5233a79"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#aa116b5b0c66b9e7f4dfd401ab5233a79">Model</a> ()</td></tr>
<tr class="memdesc:aa116b5b0c66b9e7f4dfd401ab5233a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:aa116b5b0c66b9e7f4dfd401ab5233a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81045a6f3f7fc07a1950fad87d0a321b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a81045a6f3f7fc07a1950fad87d0a321b">Model</a> (const std::string fileLocation)</td></tr>
<tr class="memdesc:a81045a6f3f7fc07a1950fad87d0a321b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that loads model from a Wavefront file.  <a href="structsmall3d_1_1_model.html#a81045a6f3f7fc07a1950fad87d0a321b">More...</a><br /></td></tr>
<tr class="separator:a81045a6f3f7fc07a1950fad87d0a321b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd2e74e9fc880456b0cdf3d75f79acd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#aecd2e74e9fc880456b0cdf3d75f79acd">Model</a> (const std::string &amp;fileLocation, const std::string &amp;meshName)</td></tr>
<tr class="memdesc:aecd2e74e9fc880456b0cdf3d75f79acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that loads model from a GLB file.  <a href="structsmall3d_1_1_model.html#aecd2e74e9fc880456b0cdf3d75f79acd">More...</a><br /></td></tr>
<tr class="separator:aecd2e74e9fc880456b0cdf3d75f79acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad5449f8e4f8b4f1f3f112a565ff91f9f"><td class="memItemLeft" align="right" valign="top"><a id="ad5449f8e4f8b4f1f3f112a565ff91f9f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#ad5449f8e4f8b4f1f3f112a565ff91f9f">alreadyInGPU</a> = false</td></tr>
<tr class="memdesc:ad5449f8e4f8b4f1f3f112a565ff91f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the model already in GPU memory? (Vulkan-specific, avoid direct manipulation) <br /></td></tr>
<tr class="separator:ad5449f8e4f8b4f1f3f112a565ff91f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc68151bf7d08e522126f6e4d0269ad"><td class="memItemLeft" align="right" valign="top"><a id="a0dc68151bf7d08e522126f6e4d0269ad"></a>
VkBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a0dc68151bf7d08e522126f6e4d0269ad">positionBuffer</a></td></tr>
<tr class="memdesc:a0dc68151bf7d08e522126f6e4d0269ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer containing vertex positions (Vulkan-specific, avoid direct manipulation) <br /></td></tr>
<tr class="separator:a0dc68151bf7d08e522126f6e4d0269ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ba40d4f09c7c398eba3a516cdd9987"><td class="memItemLeft" align="right" valign="top"><a id="a25ba40d4f09c7c398eba3a516cdd9987"></a>
VkDeviceMemory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a25ba40d4f09c7c398eba3a516cdd9987">positionBufferMemory</a></td></tr>
<tr class="memdesc:a25ba40d4f09c7c398eba3a516cdd9987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory for buffer containing vertex positions (Vulkan-specific, avoid direct manipulation) <br /></td></tr>
<tr class="separator:a25ba40d4f09c7c398eba3a516cdd9987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39db7cf562b604314c1d09e83c51fa43"><td class="memItemLeft" align="right" valign="top"><a id="a39db7cf562b604314c1d09e83c51fa43"></a>
VkBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a39db7cf562b604314c1d09e83c51fa43">indexBuffer</a></td></tr>
<tr class="memdesc:a39db7cf562b604314c1d09e83c51fa43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index buffer (Vulkan-specific, avoid direct manipulation) <br /></td></tr>
<tr class="separator:a39db7cf562b604314c1d09e83c51fa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bc354c84beb68570369cd9b831aad3"><td class="memItemLeft" align="right" valign="top"><a id="a02bc354c84beb68570369cd9b831aad3"></a>
VkDeviceMemory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a02bc354c84beb68570369cd9b831aad3">indexBufferMemory</a></td></tr>
<tr class="memdesc:a02bc354c84beb68570369cd9b831aad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory for index buffer (Vulkan-specific, avoid direct manipulation) <br /></td></tr>
<tr class="separator:a02bc354c84beb68570369cd9b831aad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec7e4ce7cea208d581c5bef94bddd59"><td class="memItemLeft" align="right" valign="top"><a id="a7ec7e4ce7cea208d581c5bef94bddd59"></a>
VkBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a7ec7e4ce7cea208d581c5bef94bddd59">normalsBuffer</a></td></tr>
<tr class="memdesc:a7ec7e4ce7cea208d581c5bef94bddd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normals buffer (Vulkan-specific, avoid direct manipulation) <br /></td></tr>
<tr class="separator:a7ec7e4ce7cea208d581c5bef94bddd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811130bb7e56af0d5e49f2707749a017"><td class="memItemLeft" align="right" valign="top"><a id="a811130bb7e56af0d5e49f2707749a017"></a>
VkDeviceMemory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a811130bb7e56af0d5e49f2707749a017">normalsBufferMemory</a></td></tr>
<tr class="memdesc:a811130bb7e56af0d5e49f2707749a017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory for normals buffer (Vulkan-specific, avoid direct manipulation) <br /></td></tr>
<tr class="separator:a811130bb7e56af0d5e49f2707749a017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d6e46a357f5216c27dec374582d4f0"><td class="memItemLeft" align="right" valign="top"><a id="a77d6e46a357f5216c27dec374582d4f0"></a>
VkBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a77d6e46a357f5216c27dec374582d4f0">uvBuffer</a></td></tr>
<tr class="memdesc:a77d6e46a357f5216c27dec374582d4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">UV coordinates buffer (Vulkan-specific, avoid direct manipulation) <br /></td></tr>
<tr class="separator:a77d6e46a357f5216c27dec374582d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9628ad75022570c3fdda0c449790cd5f"><td class="memItemLeft" align="right" valign="top"><a id="a9628ad75022570c3fdda0c449790cd5f"></a>
VkDeviceMemory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a9628ad75022570c3fdda0c449790cd5f">uvBufferMemory</a></td></tr>
<tr class="memdesc:a9628ad75022570c3fdda0c449790cd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory for UV coordinates buffer (Vulkan-specific, avoid direct manipulation) <br /></td></tr>
<tr class="separator:a9628ad75022570c3fdda0c449790cd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d7094dc24ed8d72b9bdd72eb89be67"><td class="memItemLeft" align="right" valign="top"><a id="a14d7094dc24ed8d72b9bdd72eb89be67"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a14d7094dc24ed8d72b9bdd72eb89be67">placementMemIndex</a> = 0</td></tr>
<tr class="memdesc:a14d7094dc24ed8d72b9bdd72eb89be67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of model orientation in the orientation dynamic uniform buffer (Vulkan-specific, avoid direct manipulation) <br /></td></tr>
<tr class="separator:a14d7094dc24ed8d72b9bdd72eb89be67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8d0ec778269539b3d9a5cc9b20c496"><td class="memItemLeft" align="right" valign="top"><a id="a3b8d0ec778269539b3d9a5cc9b20c496"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a3b8d0ec778269539b3d9a5cc9b20c496">colourMemIndex</a> = 0</td></tr>
<tr class="memdesc:a3b8d0ec778269539b3d9a5cc9b20c496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of model colour in the colour dynamic uniform buffer (Vulkan-specific, avoid direct manipulation) <br /></td></tr>
<tr class="separator:a3b8d0ec778269539b3d9a5cc9b20c496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9422b7594956d857bc9da9da7b13e4"><td class="memItemLeft" align="right" valign="top"><a id="adf9422b7594956d857bc9da9da7b13e4"></a>
std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#adf9422b7594956d857bc9da9da7b13e4">vertexData</a></td></tr>
<tr class="memdesc:adf9422b7594956d857bc9da9da7b13e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vertex data. This is an array, which is to be treated as a 4 column table, holding the x, y, z values in each column. The fourth column is there to assist in matrix operations. <br /></td></tr>
<tr class="separator:adf9422b7594956d857bc9da9da7b13e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b724ca272d632f25098e25ab0137a4"><td class="memItemLeft" align="right" valign="top"><a id="a06b724ca272d632f25098e25ab0137a4"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a06b724ca272d632f25098e25ab0137a4">vertexDataByteSize</a> = 0</td></tr>
<tr class="memdesc:a06b724ca272d632f25098e25ab0137a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the vertex data, in bytes. <br /></td></tr>
<tr class="separator:a06b724ca272d632f25098e25ab0137a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb0aba31845367125ed2008e12f1cac"><td class="memItemLeft" align="right" valign="top"><a id="affb0aba31845367125ed2008e12f1cac"></a>
std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#affb0aba31845367125ed2008e12f1cac">indexData</a></td></tr>
<tr class="memdesc:affb0aba31845367125ed2008e12f1cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 column table. Each element refers to a "row" in the vertex data table. Each "row" in the index data table forms a triangle. <br /></td></tr>
<tr class="separator:affb0aba31845367125ed2008e12f1cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d48b3995956a4ee42dc8c34b195ad7"><td class="memItemLeft" align="right" valign="top"><a id="a85d48b3995956a4ee42dc8c34b195ad7"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a85d48b3995956a4ee42dc8c34b195ad7">indexDataByteSize</a> = 0</td></tr>
<tr class="memdesc:a85d48b3995956a4ee42dc8c34b195ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the index data, in bytes. <br /></td></tr>
<tr class="separator:a85d48b3995956a4ee42dc8c34b195ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e45810ced27f9336e2e77bca2f8ba6"><td class="memItemLeft" align="right" valign="top"><a id="aa9e45810ced27f9336e2e77bca2f8ba6"></a>
std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#aa9e45810ced27f9336e2e77bca2f8ba6">normalsData</a></td></tr>
<tr class="memdesc:aa9e45810ced27f9336e2e77bca2f8ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array, to be treated as a 3 column table. Each "row" contains the x, y and z components of the vector representing the normal of a vertex. The position of the "row" in the array is the same as the position of the corresponding vertex "row" in the vertexData array. <br /></td></tr>
<tr class="separator:aa9e45810ced27f9336e2e77bca2f8ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62bf9713060f68517cb7ec34186e884"><td class="memItemLeft" align="right" valign="top"><a id="ab62bf9713060f68517cb7ec34186e884"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#ab62bf9713060f68517cb7ec34186e884">normalsDataByteSize</a> = 0</td></tr>
<tr class="memdesc:ab62bf9713060f68517cb7ec34186e884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the normals data, in bytes. <br /></td></tr>
<tr class="separator:ab62bf9713060f68517cb7ec34186e884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc1c38f06ad7bd19126933197e7b443"><td class="memItemLeft" align="right" valign="top"><a id="a3dc1c38f06ad7bd19126933197e7b443"></a>
std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a3dc1c38f06ad7bd19126933197e7b443">textureCoordsData</a></td></tr>
<tr class="memdesc:a3dc1c38f06ad7bd19126933197e7b443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array, to be treated as a 2 column table. Each "row" contains the x and y components of the pixel coordinates on the model's texture image for the vertex in the corresponding "row" of the vertex data "table". <br /></td></tr>
<tr class="separator:a3dc1c38f06ad7bd19126933197e7b443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3351123ddee47d7b81b9a020ca828061"><td class="memItemLeft" align="right" valign="top"><a id="a3351123ddee47d7b81b9a020ca828061"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a3351123ddee47d7b81b9a020ca828061">textureCoordsDataByteSize</a> = 0</td></tr>
<tr class="memdesc:a3351123ddee47d7b81b9a020ca828061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the texture coordinates data, in bytes. <br /></td></tr>
<tr class="separator:a3351123ddee47d7b81b9a020ca828061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d316f1a607a9bdd658aaed8341a886f"><td class="memItemLeft" align="right" valign="top"><a id="a8d316f1a607a9bdd658aaed8341a886f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a8d316f1a607a9bdd658aaed8341a886f">textureName</a> = &quot;&quot;</td></tr>
<tr class="memdesc:a8d316f1a607a9bdd658aaed8341a886f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the texture the model will be rendered with. The texture has to have been previously generated with Renderer.generateTexture(). <br /></td></tr>
<tr class="separator:a8d316f1a607a9bdd658aaed8341a886f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b123db1e9c22644c14e69e4bec3c6e"><td class="memItemLeft" align="right" valign="top"><a id="a83b123db1e9c22644c14e69e4bec3c6e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmall3d_1_1_model.html#a83b123db1e9c22644c14e69e4bec3c6e">perspective</a> = false</td></tr>
<tr class="memdesc:a83b123db1e9c22644c14e69e4bec3c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the model is to be rendered with perspective, False for orthographic rendering. <br /></td></tr>
<tr class="separator:a83b123db1e9c22644c14e69e4bec3c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A 3D model. It can be loaded from a Wavefront file. Such a file can be exported from Blender for example (see blender.org). From its menu, select File &gt; Export &gt; Wavefront (.obj). Then from the "Export OBJ" menu, only select "Write Normals", "Triangulate Faces" and "Keep Vertex Order". The 3D model can also be constructed procedurally by code, by inserting values to the appropriate member variables. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a81045a6f3f7fc07a1950fad87d0a321b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81045a6f3f7fc07a1950fad87d0a321b">&#9670;&nbsp;</a></span>Model() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">small3d::Model::Model </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>fileLocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that loads model from a Wavefront file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileLocation</td><td>Location of the Wavefront file from which to load the model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecd2e74e9fc880456b0cdf3d75f79acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd2e74e9fc880456b0cdf3d75f79acd">&#9670;&nbsp;</a></span>Model() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">small3d::Model::Model </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>meshName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that loads model from a GLB file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileLocation</td><td>Location of the GLB file from which to load the model. </td></tr>
    <tr><td class="paramname">meshName</td><td>The name of the mesh in the GLB file which will be loaded as the model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="_model_8hpp_source.html">Model.hpp</a></li>
<li>Model.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
